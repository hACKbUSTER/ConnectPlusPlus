// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/protobuf/wrappers.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(LCIM_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define LCIM_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if LCIM_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/LCIMProtocolBuffers_RuntimeSupport.h>
#else
 #import "LCIMProtocolBuffers_RuntimeSupport.h"
#endif

#if LCIM_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/LCIMWrappers.pbobjc.h>
#else
 #import "google/protobuf/LCIMWrappers.pbobjc.h"
#endif
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - LCIMWrappersRoot

@implementation LCIMWrappersRoot

@end

#pragma mark - LCIMWrappersRoot_FileDescriptor

static LCIMFileDescriptor *LCIMWrappersRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static LCIMFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPBDebugCheckRuntimeVersion();
    descriptor = [[LCIMFileDescriptor alloc] initWithPackage:@"google.protobuf"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - LCIMDoubleValue

@implementation LCIMDoubleValue

@dynamic value;

typedef struct LCIMDoubleValue__storage_ {
  uint32_t _has_storage_[1];
  double value;
} LCIMDoubleValue__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCIMDescriptor *)descriptor {
  static LCIMDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = LCIMDoubleValue_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LCIMDoubleValue__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
    };
    LCIMDescriptor *localDescriptor =
        [LCIMDescriptor allocDescriptorForClass:[LCIMDoubleValue class]
                                     rootClass:[LCIMWrappersRoot class]
                                          file:LCIMWrappersRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LCIMDoubleValue__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LCIMFloatValue

@implementation LCIMFloatValue

@dynamic value;

typedef struct LCIMFloatValue__storage_ {
  uint32_t _has_storage_[1];
  float value;
} LCIMFloatValue__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCIMDescriptor *)descriptor {
  static LCIMDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = LCIMFloatValue_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LCIMFloatValue__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
    };
    LCIMDescriptor *localDescriptor =
        [LCIMDescriptor allocDescriptorForClass:[LCIMFloatValue class]
                                     rootClass:[LCIMWrappersRoot class]
                                          file:LCIMWrappersRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LCIMFloatValue__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GPBInt64Value

@implementation LCIMInt64Value

@dynamic value;

typedef struct LCIMInt64Value__storage_ {
  uint32_t _has_storage_[1];
  int64_t value;
} LCIMInt64Value__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCIMDescriptor *)descriptor {
  static LCIMDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = GPBInt64Value_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LCIMInt64Value__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    LCIMDescriptor *localDescriptor =
        [LCIMDescriptor allocDescriptorForClass:[LCIMInt64Value class]
                                     rootClass:[LCIMWrappersRoot class]
                                          file:LCIMWrappersRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LCIMInt64Value__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GPBUInt64Value

@implementation LCIMUInt64Value

@dynamic value;

typedef struct LCIMUInt64Value__storage_ {
  uint32_t _has_storage_[1];
  uint64_t value;
} LCIMUInt64Value__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCIMDescriptor *)descriptor {
  static LCIMDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = GPBUInt64Value_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LCIMInt64Value__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    LCIMDescriptor *localDescriptor =
        [LCIMDescriptor allocDescriptorForClass:[LCIMUInt64Value class]
                                     rootClass:[LCIMWrappersRoot class]
                                          file:LCIMWrappersRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LCIMUInt64Value__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GPBInt32Value

@implementation LCIMInt32Value

@dynamic value;

typedef struct LCIMInt32Value__storage_ {
  uint32_t _has_storage_[1];
  int32_t value;
} LCIMInt32Value__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCIMDescriptor *)descriptor {
  static LCIMDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = GPBInt32Value_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LCIMInt32Value__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    LCIMDescriptor *localDescriptor =
        [LCIMDescriptor allocDescriptorForClass:[LCIMInt32Value class]
                                     rootClass:[LCIMWrappersRoot class]
                                          file:LCIMWrappersRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LCIMInt32Value__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GPBUInt32Value

@implementation LCIMUInt32Value

@dynamic value;

typedef struct LCIMUInt32Value__storage_ {
  uint32_t _has_storage_[1];
  uint32_t value;
} LCIMUInt32Value__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCIMDescriptor *)descriptor {
  static LCIMDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = GPBUInt32Value_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LCIMUInt32Value__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    LCIMDescriptor *localDescriptor =
        [LCIMDescriptor allocDescriptorForClass:[LCIMUInt32Value class]
                                     rootClass:[LCIMWrappersRoot class]
                                          file:LCIMWrappersRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LCIMUInt32Value__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GPBBoolValue

@implementation LCIMBoolValue

@dynamic value;

typedef struct LCIMBoolValue__storage_ {
  uint32_t _has_storage_[1];
} LCIMBoolValue__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCIMDescriptor *)descriptor {
  static LCIMDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = GPBBoolValue_FieldNumber_Value,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    LCIMDescriptor *localDescriptor =
        [LCIMDescriptor allocDescriptorForClass:[LCIMBoolValue class]
                                     rootClass:[LCIMWrappersRoot class]
                                          file:LCIMWrappersRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LCIMBoolValue__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GPBStringValue

@implementation LCIMStringValue

@dynamic value;

typedef struct LCIMStringValue__storage_ {
  uint32_t _has_storage_[1];
  NSString *value;
} LCIMStringValue__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCIMDescriptor *)descriptor {
  static LCIMDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = GPBStringValue_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LCIMStringValue__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    LCIMDescriptor *localDescriptor =
        [LCIMDescriptor allocDescriptorForClass:[LCIMStringValue class]
                                     rootClass:[LCIMWrappersRoot class]
                                          file:LCIMWrappersRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LCIMStringValue__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GPBBytesValue

@implementation LCIMBytesValue

@dynamic value;

typedef struct LCIMBytesValue__storage_ {
  uint32_t _has_storage_[1];
  NSData *value;
} LCIMBytesValue__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (LCIMDescriptor *)descriptor {
  static LCIMDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = GPBBytesValue_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LCIMBytesValue__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    LCIMDescriptor *localDescriptor =
        [LCIMDescriptor allocDescriptorForClass:[LCIMBytesValue class]
                                     rootClass:[LCIMWrappersRoot class]
                                          file:LCIMWrappersRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LCIMBytesValue__storage_)
                                         flags:0];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
